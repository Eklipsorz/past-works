[{
    "title": "Another Point of View： Heap Structure",
    "date": "August 5, 2020",
    "description": "另種觀點來看待Heap結構",
    "body": "\nHeap 概略 粗略地介紹Heap的構造、特性、實現  Structure Property：它是一種特殊的資料結構，其結構如同字面上的意思一樣，每個物件$Obj_i$會堆放其他物件上，最後形成一 座堆狀物：   .center { text-align: center; }   Heap Order Property：根據物件所儲存的資料來堆放其他物件上，比如以每個物件所儲存的數值來比較大小，數值比較小的節點會 堆放數值較大的節點上。\n 每當從這個結構取出物件時，會優先從結構頂端來取。\n 通常使用樹狀結構來實現，在這實現上不能夠違背前面三個提到的性質，實現上會有Initialization、Insert、Delete等Method。\n 應用：Priority Queue、Sorting。\n  Note: 似乎有很多人誤解Heap結構就是Tree結構，但其實這兩者是獨立的存在，Heap只是描述著堆狀結構，而Tree只是剛好可以拿來實現堆狀結構的另種結構。\nStructure Property 定義該結構會是什麼 在這個結構內，每個物件都堆放在其他物件上，進而使整體結構像是堆狀物，當我們指定被堆放的最大物件數時，我們會稱之為$k$-ary Heap，$k$為物件數 ，如果$k = 2$就代表著每個物件只能堆放在$0-2$個物件上(如下圖中的左半邊)，而如果$k = 3$就代表著每個物件只能堆放在$0-3$個物件上，不管$k$是為何 ，Heap下的每個節點會像下圖中那樣排列著，而圖中的obj指的就是堆放物，而$1-k$指的是被堆放物。\n .center { text-align: center; }   理想狀態下，我們可以透過本性質將每個節點堆成一座小山，最後再將每座小山構成一座大山，比如說在Binary Heap下，原本每個節點構成的小山(下圖左半邊) 會被堆放在一起形成一座大山(下圖右半邊)。\n .center { text-align: center; }   Heap Order Property 根據Structure Property提到的內容，這些物件會構成一個堆狀物，但內容卻沒指定這些物件彼此間關係是為何，而且當要從堆狀物取出物件時，取出的物件會在 不確定的情況下變得毫無意義，因爲我們並不能知道每此取出的物件會是什麼，所以為了讓取的物件更加有意義而添加Heap Order Property。\n定義這些物件彼此間的關係 我們會根據物件儲存的數值來決定如何堆放，通常會有兩種堆放基準：\n 物件的數值比其他物件儲存的數值來得小時，就堆放在他們上面 物件的數值比其他物件儲存的數值來得大時，就堆放在他們上面  不論選取哪個來堆放物件，該結構上的頂端物件肯定是所有物件裡最小或者最大的，然而如果在這個結構上混用這兩種方式，該頂端物件並不能夠保證其結果的大小 關係。此外，若我們單純使用第一個基準來堆放物件，那麼最後得到的Heap會根據取出的數值是最小的而被稱之為Min Heap；反之，若我們單純使用第二個基準來堆 放物件，那麼最後得到的Heap會被稱之為Max Heap。\n對於這兩個基準的實現方式，會使用Tree結構的Parent節點和其所擁有的Child節點來表示堆放物件以及被堆放的物件。\nHow to get object from the structure 基本上會先取得該結構上的頂端物件來盡量不破壞Structure Property，同時使用已在Heap的物件來代替頂端物件來維持著兩種特性，另外當我們想從多個物件中找 尋擁有最小值或最大值的物件時，該結構會很有效地幫助我們尋找，因爲頂端物件不是擁有最小值的物件，就是擁有最大值的物件。\nHeap Example 以Binary Heap以及它帶有的Method來更清楚地介紹Heap 根據Structure Property談到的定義：當我們指定被堆放的物件數時，我們會稱之為k-ary Heap，在這裡如果我們要堆放的物件數是2個時，我們會稱之為Binary Heap ，我們可以透過Binary Tree(BT)的左右子樹節點就能表示，換言之，每個節點能夠連接兩個相同型態的節點。在Binary Tree下的Structure Property和Heap Order Property 這兩個性質會在保持著Heap的原有性質的情況下更加強調Binary Tree的實作。\nBT: Structure Property 在Structure Property上，會為了更加簡單地透過Array來實作Binary Tree而強調該樹狀結構必須是Complete Tree為原則，換言之，除了最後一層的節點之外，每層的 節點數都必須是$2^k$個節點，而$k$是表示第$k$個階層，而最後一層的節點數可以少於 $2^m$ ($m$為最後一層的階層第次) 個且在這階層中的節點必須連續地排列在同 一個階層，舉例來說，我們會預期最後一層的節點位置會是下圖，而這些白圈並沒有放置任何節點，但若在該位置放入節點時便會以灰圈來表示，\n .center { text-align: center; }   當指定該樹狀結構為Complete Tree時，節點位置$A1$至某個位置之間的位置都必須存在著節點，我們可以用下圖左右兩邊來表示，左邊代表著節點位置$A1$至某個位置之 間的位置都存在著節點，而右邊會是全部的位置都被節點佔據著。你可以看到這些節點們都連續地擺放在一起，\n .center { text-align: center; }   然而，若節點位置$A1$至某個位置之間的位置存在著白圈的話(如下圖)，此時的樹狀結構就不為Complete Tree。\n .center { text-align: center; }   當我們依照這樣實作規則製作出Complete Binary Tree並且由上層來依序給予序號(如下圖)，會發現每個節點$i$的子節點會是節點$2i$或者節點$2i+1$，這時我們就可以\n .center { text-align: center; }   直接宣告一個固定大小的陣列來實作Binary Tree，並且利用節點與其子節點的序號關係來存取，index為1的記憶體空間為root節點，而root節點的子節點就是index為2~3的 記憶體空間，當我們想存取某節點$i$的子節點時，便直接朝著index為$2i$以及$2i+1$的記憶體空間來存取。\nBT: Heap Order Property Heap Order Property在這裡會以數值系統來比較並且採用以Min Heap為主的基準來建立Heap，也就是說會拿每個物件所儲存的數值來將每個節點堆積到另外兩個數值比較大的 節點上。\nBT: How to get object from the structure 而當我們要從Heap結構取出物件時，便是拿Binary Tree上的root節點，並且從剩餘節點中挑出適當的節點來頂替root節點以維持Structure Property和Heap Order Property這 兩個性質。\nBT: Implementation 定義了Heap的ADT並按照ADT來寫出對應的Pseudo Code。 在這ADT(如下圖)中，我們定義了Heap是什麼、存放什麼物件、它擁有哪些可以對自己處理的操作，在這裡我們以建構Min Heap為主，首先我們可以透過在用Binary Tree實作時強調的性 質直接將每個Heap當成固定大小的陣列，並且以該陣列以及其他參數$item$、$n$來當作每個函式的輸入參數。參數$item$在Heap結構中會是每個節點會儲存的資料，而每個$item$可以是 不同型態的資料，在這裡將它設定成$Element$型態以保持彈性，最後$n$則是正整數(包含0)，定義陣列所擁有的節點總數，通常會使用函式$getHeapSize(heap)$來獲取對應的總數並放入 $n$.\n .center { text-align: center; }   函式部分則有$isEmpty$、$isFull$、$top$、$insert$以及$DeleteMin$等基本函式，$isEmpty$和$isFull$(如下圖所表示的兩個演算法)會根據結構內的節點總數來判別該Heap是否空或者是 否滿，當總數(此時由$n$變數存放)等於0時，就表示heap結構沒有任何節點；而當總數等於該heap結構能存放的容量$MaxSize$時，就表示Heap結構的節點總數到達該結構能夠存放的容量。\n .center { text-align: center; }    .center { text-align: center; }   而$top$函式則是固定獲得Heap結構的頂端物件或者頂端節點，在這裡以陣列中的第1個位置上的物件來表示頂端節點，其中第0個位置由於其位置數是代表0，很難去直接用它來做$i*2$ 和$i/2$來存取child和parent這兩個節點，因此都跳過該位置並拿它下一個位置當作是頂端節點。\n .center { text-align: center; }   $Insert$函式(如下圖所示)會在維持前面所述的兩種性質下將$item$放入該結構中，首先該算法將在第5、6、10行預先將要放入的$item$定義成$NewElement$並且在樹狀結構新增一個 擁有空值的節點或者說佔用陣列中的第$n+1$個位置($n$為目前存有$item$的節點數)，\n .center { text-align: center; }   其結果如下所示：\n .center { text-align: center; }   圖中的左邊是新增空節點之前，而右邊則是之後的結果，接下來的過程中將會用白圈代表著目前是空值的節點，而第7行的$shiftUp$(過程如下圖)拿新增加的節點(第$n+1$個節點)對應的parent節點 (為下圖的橘圈)與$NewElement$進行第一次的$item$之數值比較，當parent節點的數值比較大時，便把parent節點的$item$放入新增加的節點(白圈)裡，而此時白圈會用紅圈表示該節點已經被填入 $item$，而此時的白圈將由原本的parent節點來替代，接著我們再以目前白圈的parent節點來和$NewElement$進行第二次的$item$之數值比較，若parent節點還是比較大時，則會像第一次那樣，原 本的白圈會擁有此時的parent節點所存下的$item$，而parent節點則以白圈來替代，\n .center { text-align: center; }   這樣的流程持續到當$NewElement$比較大時，此時的結果會像是如下圖這樣，代表橘圈的節點擁有比較小的$item$，而白圈下的節點都擁有著比$NewElement$還大的$item$，\n .center { text-align: center; }   而面對這樣子的情況，我們可以直接將$NewElement$放入白圈中以維持性質。當然如果白圈已經移動至結構的頂端位置時，會因爲$h[0]$所存的值而被迫只能留在$h[1]$或者目前頂端位置，而這時我 們只需要將$NewElement$填入至白圈即可。\n補充：從這樣的流程來看，我們一直不斷往上移動白圈直到移動到適當位置，並放入$NewElement$至白圈內部，所以將此處理方式命名為$shiftUp$。\n .center { text-align: center; }   最後的$DeleteMin$函式會優先取得Heap結構上的頂端節點，也就是$h[1]$，此時的頂端節點會因爲被取走的關係而不能夠繼續存在該結構中，所以必須透過第七行的$shiftDown$函式從剩下的 節點挑出適合節點來頂替它以維持Heap結構原本要有的性質，該$shiftDown$函式跟$shiftUp$函式雷同，只是白圈會從頂端的位置往下移動，最後由第二十五行提到的$LastElement$來放入白圈 中。\n .center { text-align: center; }   首先我們進入$DeleteMin$函式之前，我們所擁有的Heap結構會如同下圖：\n .center { text-align: center; }   接著我們依照算法的指示先取得頂端節點和最後一個節點(如下圖)，頂端節點會在第六、八行回傳給呼叫者以保證呼叫者能從中拿到最小值之$item$，而最後一個節點$LastElement$會優先在第十行 取得並在第二十五行找出適當位置來放入白圈中。\n .center { text-align: center; }   而當我們取得指定的節點時，便會在第十一行扣除掉最後一個節點來用while結構計算白圈的適當位置，在while結構內部中，我們設定 $i*2 \\leq n$ 當作成立條件來存取Heap結構下的子節點，而 該結構中除了leaf節點和擁有第$n$個子節點的節點之外，其他節點都因爲結構上是complete tree而擁有兩個子節點，當我們想要存取leaf節點的子節點便會因爲while的條件而被避免，而擁有第 $n$個子節點的節點則會因爲第十五行的條件來避免程式認為有兩個子節點而存取錯誤，不管是遇上哪個例外，這些情況下，都會透過第二十五行來將$LastElement$放入當前節點中，而非直接處理 例外的子節點。\n那麼考慮擁著有兩個子節點的節點，一開始進入while時，我們會像下圖中的第一次一樣先將頂端節點位置設定成白圈並找到其child節點，並且拿他們所擁有的$item$來和$LastElement$比較(第一 次的橘圈表示當前要被比較的節點)，當child節點之一比較小時，較小的節點便像圖中第二次的第二個節點那樣頂替白圈，而原本的節點就變成白圈，接著我們再以白圈為主的child節點和$LastElement$ 進行比較(第二次的橘圈來表示當前要被比較節點)，若還是child節點之一比較小時，較小的節點就如同第三次的第四個節點那樣，然後再挑出child節點和$LastElement$來比較，接著大小關係還是一樣的 狀況時，就會像是第四次，每一次的相同比較結果出現都會使得白圈往下移動，\n .center { text-align: center; }   然而，當遇到$LastElement$比較小或者遇上比較例外的子節點而僅剩$LastElement可以比較(如下圖)時，\n .center { text-align: center; }   這時我們可以將$LastElement$放入當前白圈中，這樣的處理剛好滿足了Heap結構的性質。\n .center { text-align: center; }   結論 雖然Heap結構上在每本書中都會有一定程度上的解釋，但大部分都把Heap結構視作為Tree結構來解釋，而非直接強調兩者是獨立的結構來說明。為此，我寫下了這篇文章心得簡單地描述 Heap結構和Tree結構兩者間的獨立性以及強調Tree結構只不過是實現Heap結構的其中一個手段，接著再用Binary Tree來構築一個Heap結構以及它會有什麼樣的基本操作。另外程式碼的部 分我不會使用某種特定語言來侷限於看得懂語法的人，而是直接採用比較中立的Pseudo code來說明如何用Binary Tree構築。\n",
    "ref": "/blog/heapinfo/"
  },{
    "title": "LeetCode Study: Top 100 Liked Questions",
    "date": "August 5, 2020",
    "description": "關於100個經典LeetCode題目的研究心得",
    "body": "\n為了追蹤自己曾寫過的題目以及對於其題目所想到的思路而建立以下表格，其中該表格的欄位分為題目和研究心得連結，研究心得連結是自己擁有的hackmd筆記連結， 有些筆記可能還存在著一些瑕疵，這部分會在短期內完成修改，並且記錄其他題目。另外NIL代表著還未有對應的筆記連結，換言之，還沒開始寫那題目的筆記XD。\n   題目 研究心得連結     Two Sum https://hackmd.io/@eklipsorz/H1Rup1PF8   Add Two Numbers NIL   Longest Substring Without Repeating Characters NIL   Median of Two Sorted Arrays NIL   Longest Palindromic Substring NIL   Regular Expression Matching NIL   Container With Most Water NIL   3Sum NIL   Letter Combinations of a Phone Number NIL   Remove Nth Node From End of List NIL   Valid Parentheses https://hackmd.io/@eklipsorz/ryn15Vt5U   Merge Two Sorted Lists https://hackmd.io/@eklipsorz/r1okmM0vL   Generate Parentheses NIL   Merge k Sorted Lists NIL   Longest Valid Parentheses NIL   Search in Rotated Sorted Array NIL   Find First and Last Position of Element in Sorted Array NIL   Combination Sum NIL   First Missing Positive NIL   Trapping Rain Water NIL   Permutations NIL   Rotate Image NIL   Group Anagrams NIL   Maximum Subarray https://hackmd.io/@eklipsorz/BymotGetI   Jump Game NIL   Merge Intervals NIL   Unique Paths NIL   Minimum Path Sum NIL   Climbing Stairs https://hackmd.io/@eklipsorz/Hy3TA_YdL   Edit Distance NIL   Sort Colors NIL   Minimum Window Substring NIL   Subsets https://hackmd.io/@eklipsorz/HJWLg-QkD   Word Search NIL   Largest Rectangle in Histogram NIL   Maximal Rectangle NIL   Binary Tree Inorder Traversal NIL   Unique Binary Search Trees NIL   Validate Binary Search Tree NIL   Symmetric Tree NIL   Binary Tree Level Order Traversal NIL   Maximum Depth of Binary Tree https://hackmd.io/@eklipsorz/HkIpIfRv8   Construct Binary Tree from Preorder and Inorder Traversal NIL   Flatten Binary Tree to Linked List NIL   Best Time to Buy and Sell Stock https://hackmd.io/@eklipsorz/BJuq1iAFI   Binary Tree Maximum Path Sum NIL   Longest Consecutive Sequence NIL   Single Number https://hackmd.io/@eklipsorz/SJtK5qpvI   Copy List with Random Pointer NIL   Word Break NIL   Linked List Cycle https://hackmd.io/@eklipsorz/ryusl4Z5L   Linked List Cycle II https://hackmd.io/@eklipsorz/ryXLRDM5I   LRU Cache NIL   Sort List NIL   Maximum Product Subarray NIL   Min Stack NIL   Intersection of Two Linked Lists https://hackmd.io/@eklipsorz/BkzWzfSqU   Majority Element NIL   House Robber https://hackmd.io/@eklipsorz/BJtNPeJ9I   Number of Islands NIL   Reverse Linked List NIL   Course Schedule NIL   Implement Trie (Prefix Tree) NIL   Word Search II NIL   Kth Largest Element in an Array NIL   Maximal Square NIL   Invert Binary Tree NIL   Kth Smallest Element in a BST NIL   Palindrome Linked List https://hackmd.io/@eklipsorz/Hy2iQYLcI   Lowest Common Ancestor of a Binary Tree NIL   Product of Array Except Self NIL   Sliding Window Maximum NIL   Search a 2D Matrix II NIL   Meeting Rooms II NIL   Perfect Squares NIL   Move Zeroes NIL   Find the Duplicate Number NIL   Serialize and Deserialize Binary Tree NIL   Longest Increasing Subsequence NIL   Remove Invalid Parentheses NIL   Best Time to Buy and Sell Stock with Cooldown NIL   Coin Change NIL   House Robber III NIL   Counting Bits https://hackmd.io/@eklipsorz/rJZhS6s9U   Top K Frequent Elements NIL   Decode String NIL   Queue Reconstruction by Height https://hackmd.io/@eklipsorz/BkTVFwLj8   Partition Equal Subset Sum NIL   Path Sum III https://hackmd.io/@eklipsorz/Hyo1xWVF8   Find All Anagrams in a String NIL   Find All Numbers Disappeared in an Array NIL   Target Sum NIL   Diameter of Binary Tree https://hackmd.io/@eklipsorz/rk0EVrwdL   Subarray Sum Equals K NIL   Shortest Unsorted Continuous Subarray https://hackmd.io/@eklipsorz/rJcz6ic58   Merge Two Binary Trees NIL   Task Scheduler NIL   Palindromic Substrings NIL   Daily Temperatures https://hackmd.io/@eklipsorz/BkMYGyaoI    ",
    "ref": "/blog/100mostproblems/"
  },{
    "title": "Introduction: Floyd Cycle Detection",
    "date": "July 21, 2020",
    "description": "利用兩個指標(Pointer)來解決List上的循環問題",
    "body": "\n當你想解決任何一個需要檢測在多個相互連接的元素是否存在著循環結構之場景，比如說\n 道路模型。\n 由多個有限狀態所組成的數學模型。\n 有限輸入下在同一個函式$f(x)$所形成的結果，比如集合為$\\{1,2\\}$，且$f(1)=2$以及$f(2)=1$，在這裏1和2就透過函式關係形成一個循環結構。  我們可以將這些場景轉化成由多個節點構成的List結構，並且大致區分為兩種不同結構：\n 擁有循環結構的List結構 \n 沒擁有循環結構的List結構\n  \n當我們轉換成如此的結構時，我們可以更容易以肉眼看出哪些模型存在著循環，在這裏我們可以知道List A是存在著循環，而List B由於尾巴部分並未跟 前幾個節點相接，所以不構成循環。在這裡你或許會選擇以肉眼來辨識，但現實是當面對大量或者複雜的模型時，肉眼看會顯得效率太差，所以最好由電 腦進行這樣的重複辨識工作。\n可換作是電腦，它要如何辨識呢？畢竟他本身就不存在像人眼那樣的辨識模型，在這裏提供一個方法來幫助電腦辨識：Floyd's Cycle Detection Algorithm， 據說是由Robert W. Floyd所發明的演算法，所以以他的名字來命名，普遍上會以演算法的特色來稱呼：龜兔賽跑算法。顧名思義，這個演算法會假設一隻烏龜和 一隻兔子在這個許多節點構成的List結構進行賽跑，烏龜每次只能走一個節點，而兔子只能走二個節點，如果List結構存在著循環，他們只要跑下去肯定能到循環 裡，並且他們肯定能在循環中碰面或者在同一點會合的話。\n .center { text-align: center; }   然而，如果兔子走到結構中的終點卻沒跟烏龜會合的話，那就表示著結構不存著循環。(如下圖)\n .center { text-align: center; }   乍看之下這方法很簡單，但問題是這方法真能判別循環問題嗎？如果你對此也感到懷疑，歡迎到Proof章節來進行討論，但如果沒有的話，我可以告訴你 這方法確實能判別循環問題，而非是運氣，另外也建議讀者您參考Implementation以及Performance這兩個章節來看其代碼以及成本。\nProof:How it works? 首先我們先來考慮擁有循環的結構(如下圖)，在循環之前可能會有$N$個點或者沒存在任何節點，而這$N$的值會影響著烏龜和兔子在循環中的初始位置，再來 為了很好地地瞭解影響，設定了數字來表示循環中的第幾個節點，以$0$到$\\lambda-1$來命名，而$\\lambda$則是定義成循環中的長度，在這裡$\\lambda=10$。\n .center { text-align: center; }   首先我們先考慮著$N=0$時，兔子和烏龜會在循環的起點會合，並從那裡開始進行他們的賽跑。\n .center { text-align: center; }   根據兔子走兩步和烏龜走一步的前提，當兔子走完一圈時，烏龜才走半圈，而兔子再走完下一個完整的圈時，這時烏龜才走完一圈，此時他們倆就在一開始的點會合。\n在這裡，我們會發現幾個有趣的觀察結果：\n 兔子得走完一圈才有辦法跟烏龜會合(p.s 他們倆不動也能會合XD，但這不是在該方法的討論範圍內)\n 兔子$H$的步數會是烏龜$T$的步數之一倍，換言之，$H=2T$。\n 當兔子$H$和烏龜$T$都走到循環內部時，我們可以對$H$和烏龜$T$使用同餘($mod\\ \\lambda$)的概念(如下式)來 確定是否存在循環，若兩者的餘數都一樣那就表示存在著循環；反之，就是不存在。\n .mathformula { text-align: center; }  $H≡T$ ($mod\\ \\lambda$)\n   將第二個觀察結果納入至$H≡T$ ($mod\\ \\lambda$)便會是如下式：\n .mathformula { text-align: center; }  $2T≡T$ ($mod\\ \\lambda$)\n 統整這三個觀察結果，我們會發現只要$T=\\lambda$ 代入上式，兔子和烏龜會在第$0$個節點會合。接下來我們思考另一種情況，如果$N=1$時，這種代入結果會不會有 所不同？\n .center { text-align: center; }   從上圖可以觀察出當烏龜進入循環時的位置跟兔子所在的位置是不同的：兩者相差一個節點，這對於$N=0$所得出的觀察結果而言，我們可以確定兔子還是得走完一圈才 有辦法和烏龜在同一點，而第二、三個觀察結果可能會因為這樣而改變。\n當烏龜進入循環的起點時，兔子在循環中的位置會變成($H'$為循環中的新位置，$H$為循環中的舊位置)：\n .mathformula { text-align: center; }  $H\u0026#39;=H\u0026#43;1$\n 接著第三個觀察結果會因循環外的節點增加而改變成下式：\n .mathformula { text-align: center; }  $H\u0026#43;1≡T$ ($mod\\ \\lambda$)\n 在兩者移動的過程中，仍然依照烏龜每走一步，兔子就會走兩步這前提，只是現在兔子比起原本多走了一步，所以我們可以將上式更改成：\n .mathformula { text-align: center; }  $2T\u0026#43;1≡T$ ($mod\\ \\lambda$)\n 你會發現這與$N=0$所發現的第二、三個觀察結果有些出入，在這裡第二個觀察結果會變成$H'=2T+1$，而第三個觀察結果就是上式。\n那麼式子的改變會不會影響與烏龜會合的情況呢？其實只要我們按照圖上位置來模擬他們移動，最後會發現他們的確會在同一點會合，只是位 置變成第$\\lambda-1$個位置，在這裡會是循環中編號9的位置，也就是說上式要達到同餘的效果就只有兩者都走到第九個位置(在這裡我們先假 定式子的同餘結果會是$9$，後續推理到$N=M$時來驗證)\n接著我們再來思考一下$N=2$時，會有什麼樣的變化  .center { text-align: center; }   同樣的，由於只是單純增加循環外面的節點，同樣地，由於位置因爲循環外的節點增加而改變第二、三個觀察結果，此時兔子的新位置會是：\n .mathformula { text-align: center; }  $H\u0026#39;=H\u0026#43;2$\n 而第二個觀察結果會變成是$H'=2T+2$，第三個觀察結果就變成是\n .mathformula { text-align: center; }  $2T\u0026#43;2≡T$ ($mod\\ \\lambda$)\n 接著我們只要按照圖上位置來模擬他們移動就會發現他們的確也是會在同一點上會合，但這次是第$\\lambda-2$個節點或者第8個節點上會合， 如果考慮成$N=3$時，會發現會在第$\\lambda-3$個節點或者第$7$個節點上會合，而$N=4$時，會發現在第$\\lambda-4$個節點或者第$6$個節點 上會合。\n那麼最後我們來試著考慮著$N=M$的情況，而$M$的數值範圍為$[1,∞)$\n .center { text-align: center; }   當烏龜進入循環時，兔子的預期位置變成：\n .mathformula { text-align: center; }  $H\u0026#39;=H\u0026#43;M$\n 在這裡我們還不確定這種情況是否同樣地使烏龜和兔子會在同一點會合，所以我們先假設他們肯定能在某一點會合來驗證其正確性。\n我們考慮著以下式子：\n .mathformula { text-align: center; }  $H\u0026#43;M≡T$ ($mod\\ \\lambda$)\n 同樣地，我們將烏龜走一步和兔子走兩步的前提納入進式子，就變成：\n .mathformula { text-align: center; }  $2T\u0026#43;M≡T$ ($mod\\ \\lambda$)\n 根據前面所述的第ㄧ、二觀察結果，兔子必須至少得繞ㄧ圈才有機會與烏龜會合，但這樣單純繞幾圈也只是與烏龜保持$M (mod\\ \\lambda) -(\\lambda-2M) (mod\\ \\lambda)$個節點的差距，所以兔子和烏龜還必須在繞幾圈之後再多走個幾步才有機會會合，所以烏龜式子會變成如下：\n .mathformula { text-align: center; }  $T=N_1\\lambda\u0026#43;N_2$ (烏龜繞了$N_1$圈又$N_2$步)\n 接著將上式代入$2T+M≡T$ ($mod\\ \\lambda$)就會是：\n .mathformula { text-align: center; }  $2(N_1\\lambda\u0026#43;N_2)\u0026#43;M≡N_1\\lambda\u0026#43;N_2$ ($mod\\ \\lambda$)\n 根據$mod\\ \\lambda$，我們可以化簡成：\n .mathformula { text-align: center; }  $2N_2\u0026#43;M≡N_2$ ($mod\\ \\lambda$)\n 根據先前$N=2-4$情況得到的觀察結果，會發現都會在第$\\lambda-N$個節點會合，那麼同樣地將其結果套用在上式時，\n .mathformula { text-align: center; }  $N_2=\\lambda-M$\n 會發現式子會變成如下:\n .mathformula { text-align: center; }  $2(\\lambda-M)\u0026#43;M≡(\\lambda-M)$ ($mod\\ \\lambda$)\n 再稍微用$mod\\ \\lambda$來化簡，則會是：  .mathformula { text-align: center; }  $-M≡-M$ ($mod\\ \\lambda$)\n 而這相當於在第$\\lambda-M$個節點或者第$\\lambda-N$個節點會合\n .mathformula { text-align: center; }  $\\lambda-M≡\\lambda-M$ ($mod\\ \\lambda$)\n 從這樣推論驗證了$N$在$[1,∞)$範圍內的節點數所構成循環時可以使兔子和烏龜在第$\\lambda-N$個節點會合，其中$N=M$。\n .CodeContext { display: block; overflow-x: auto; padding: .5em; color: #333; background: #f8f8f8; border-style: solid; border-color: #000000; } .title{ font-size: 1.25vw; text-align: center; }  補充：\n其中$\\lambda-M$中的$\\lambda$其實原本是考慮成$N’\\lambda$，但由於最後還是會因爲$mod\\ \\lambda$而跟$\\lambda-M$的最後結果一樣，且如果寫$N’\\lambda-M$的話，會不容易理解，在這裏簡化成最後解。\n 此外，如果讀者願意花更多時間觀察的話，只要畫個圖並標示起點、會合點、距離的話(如下圖），會發現只要$N$與$\\lambda-N$ 相加就能構成循環長度，換言之，從起點1到會合點之間的節點數剛好是循環的長度。\n .center { text-align: center; }   另外剩下沒包含到的節點(用橘線來表示的節點)數量剛好會是循環外的節點數$N$。\n .center { text-align: center; }   還有如果我們限制烏龜只能在循環內走不到一圈來和兔子會合，會得到一個有趣的觀察結果，其中烏龜走不到半圈時會使 兔子永遠會合不了，因此烏龜的步數要滿足走不到一圈以及會合的條件必須是半圈以上至一圈的範圍，所以，原本的式子 會改變成如下：\n .mathformula { text-align: center; }  $T=\\frac{\\lambda}{2}\u0026#43;M_1$\n 代入式子$2T+M≡T$會形成：\n .mathformula { text-align: center; }  $2(\\frac{\\lambda}{2}\u0026#43;M_1)\u0026#43;M≡\\frac{\\lambda}{2}\u0026#43;M_1$ ($mod\\ \\lambda$)\n 稍微處理一下，就能簡化成：  .mathformula { text-align: center; }  $2M_1\u0026#43;M≡\\frac{\\lambda}{2}\u0026#43;M_1$ ($mod\\ \\lambda$)\n 同時我們可以用先前得到的驗證結果來反證這樣子是否出現矛盾，首先右邊的式子在這前提下，必須等於$-M$或者$\\lambda-M$ ，那麼\n .mathformula { text-align: center; }  $M_1=\\frac{\\lambda}{2}-M$\n 將這個假設結果代入式子$2M_1+M≡\\frac{\\lambda}{2}+M_1$就變成：\n .mathformula { text-align: center; }  $-M≡-M$ ($mod\\ \\lambda$)\n 這樣子的結果等同於先前驗證結果，換言之，烏龜只需要繞半圈以上至一圈的距離就能和兔子會合。\n .CodeContext { display: block; overflow-x: auto; padding: .5em; color: #333; background: #f8f8f8; border-style: solid; border-color: #000000; } .title{ font-size: 1.25vw; text-align: center; }  補充：\n先前我們假設烏龜和兔子會花好幾圈又幾個節點才能使他們會合，在這好幾圈又幾個節點的範圍內包含了無數個排列組合，比如2圈又5個節點，現在我們利用限制發現了其實烏龜走不到半圈就能會合。但這過程中，兔子還是得至少走一圈才能會合。\n 基於這幾個推論結果，我們可以更改$N=0$的觀察結果：\n 兔子得走完一圈才有辦法跟烏龜會合(p.s 他們倆不動也能會合XD，但這不是在該方法的討論範圍內)。\n 考慮著循環內外節點數時，兔子$H$和烏龜$T$在循環內的位置關係會是$H'=2T+N$，而$N$是節點外的節點數。\n 當兔子$H$和烏龜$T$都從循環外部走到循環內部時，我們可以對$H$和烏龜$T$使用同餘($mod\\ \\lambda$)的概念(如下式)來 確定是否存在循環，若兩者的餘數都一樣那就表示存在著循環；反之，就是不存在。(其中$N$為循環外的節點數)\n .mathformula { text-align: center; }  $H\u0026#43;N≡T$ ($mod\\ \\lambda$)\n  延伸第三個觀察結果，會發現兔子和烏龜的會合點會是第$\\lambda-N$個節點或者第$\\lambda-M$個節點。\n 循環起點到會合點的節點數可以和循環外的節點數構成循環長度，換言之，$\\lambda = $循環起點到會合點的距離+ 循環外的節點數。\n 烏龜只需要繞半圈以上至一圈的距離就能和兔子會合。\n  第$1$個觀察結果因爲本身不受循環以外的節點數影響，所以不會進行變動，但原本第$2-3$個結果會隨之影響，使之擴展成考慮成$M$個循環以外的 節點，而第$4-5$個結果則是因爲第三個結果的推論過程而新增過來的。\nPseudo Code 根據Floyd's Cycle Detection所描述的演算法而寫出的Pseudo Code，其中使用$next[i]$和$head[i]$來分別代表變數$i$的下一個節點以及 其頭部節點，而NIL在這裡代表不存在任何節點。\n .center { text-align: center; }   該演算法以List為輸入參數，當List輸入進去時，會先設定其頭部的位置給兔子和烏龜這兩個變數，接著為了他們兩個變數能夠在不影響系統的情況下 跑遍整個List結構，所以設定了While以及其條件$Hare\\ \\neq\\ NIL$ and $next[Hare] \\neq NIL$，其條件主要會檢測目前兔子所走的位置是否能繼續走， 最後兔子和烏龜會依照規則來走指定步數，當他們所在的位置是一樣時，就代表著此List結構確實存在循環而回傳True，反之兔子走到盡頭都沒遇到烏龜而 回傳代表不存在循環的False。\nImplementation 程式碼連結：bit.ly/2FKotVP\n使用EAFP程式碼風格來取代過度的if-else檢查，並從中提升速度，另外先讓在try區塊中的兔子多走一步以避免while迴圈判斷到錯誤的情況 ，同時這樣子的移動方式並不會改變兔子和烏龜的會合結果，只不過變成$M+1$個循環外節點的情況來移動。\nPerformance 時間複雜度：考慮該方法應用在不存在循環以及存在循環的場景中，時間複雜度範圍會是$O(N_1+N_2)$-$O(\\lambda+N)$，其中的$N_1$ 是循環外的起點1至循環內的起點2的節點數，而$N_2$是循環內的起點2至烏龜與兔子預計會合點之間的節點數(如下圖)，而$\\lambda$是 循環的長度以及N為循環外的節點數，$N_1$、$N_2$、$\\lambda$和$N$這四個大小關係會因爲第六個觀察結果而會是$\\lambda+N≥N_1+N_2$。\n .center { text-align: center; }   空間複雜度：該方法本身不需要向系統索求額外記憶體空間或者內存來進行判斷，所以空間複雜度會是原本一般執行程式碼所需要用到的記憶體 大小，也就是$O(1)$。\nConclusion 我們利用一些場景來說明循環問題，接著將這些場景轉化成電腦可以判斷是否有循環的List結構，最後我們提出知名的龜兔賽跑算法來幫助電腦 判斷該List結構是否有循環。除此之外，我們也額外提供讀者一些章節來描述該方法是如何成功地判斷、如何實現以及其算法的執行成本。\n",
    "ref": "/blog/floydcycledetect/"
  },{
    "title": "Contact",
    "date": "July 21, 2020",
    "description": "",
    "body": "",
    "ref": "/contact/"
  },{
    "title": "About",
    "date": "July 20, 2020",
    "description": "定義本網站的存在意義",
    "body": "網站介紹 我是一位熱愛知識和實踐的平凡人，在追求著兩者的期間記錄了不少有趣的研究心得以及程式作品，研究心得有哥德爾不完備定理、Floyd\u0026rsquo;s Cycle Detection、 Catalan Number和括號子集合的關係、樹旋轉緣由等心得，而程式作品有針對多台Xen虛擬機之間的動態記憶體分配、RMS/EDF Schedule Algorithm的工作模擬， 只可惜那期間都用紙筆和私有的Evernote筆記去紀錄過程，這樣無法和人分享這些知識，為了解決這問題，就建立了儲思盆來重新記錄這些事物，希望有朝一日 遇到同好一起來討論這些XD\n作者介紹 在這裡稱我為Eklipsorz就行，本名就算了XD。\n興趣：研究知識、寫寫程式\n喜愛的研究主題：電腦科學、哲學、數學、生物學(尤其是基因)\n擅長的程式語言：C/C++ （僅列出比較擅長)\n",
    "ref": "/about/"
  }]
